Optional is a class (not interface).
It supports functional programming by using functional interfaces internally.
This design helps us write null-safe, readable, and concise code.

static <T> Optional<T> empty()
static <T> Optional<T> of(T value)
static <T> Optional<T> ofNullable(T value)

boolean isPresent()
boolean isEmpty() // Since Java 11
T get()
T orElse(T other)
T orElseGet(Supplier<? extends T> supplier)
<T extends X> T orElseThrow(Supplier<? extends X> exceptionSupplier)

void ifPresent(Consumer<? super T> action)
void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) // Java 9
Optional<T> filter(Predicate<? super T> predicate)
<U> Optional<U> map(Function<? super T, ? extends U> mapper)
<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)


import java.util.*;
import java.util.stream.*;

public class TestOptional {
    public static void main(String[] args) {
        List<Employee> list = Arrays.asList(
            new Employee("Alice"),
            new Employee("Bob"),
            new Employee("Arun")
        );

        Optional<List<Employee>> optionalEmployees = Optional.ofNullable(list);

        List<Employee> filtered = optionalEmployees
            .filter(l -> !l.isEmpty())
            .map(l -> l.stream()
                       .filter(e -> e.name.startsWith("A"))
                       .collect(Collectors.toList()))
            .orElse(Collections.emptyList());

        filtered.forEach(System.out::println);
		
    }
}
Exp:1

		List<Optional<String>> list = Arrays.asList(
			Optional.of("A"),
			Optional.empty(),
			Optional.of("B")
		);

		List<String> filtered = list.stream()
			.flatMap(opt -> opt.map(Stream::of).orElseGet(Stream::empty))
			.collect(Collectors.toList());

		System.out.println(filtered); // Output: [A, B]



.flatMap(opt -> opt.map(Stream::of).orElseGet(Stream::empty))
opt is an Optional<T>, and this unwraps the value into a Stream<T>.
Used inside .flatMap() to flatten multiple Optionals into a single stream of values.
✅ opt.map(Stream::of)
map is a method on Optional<T>, which transforms the value if present.
Stream::of is a method reference that wraps a value into a Stream.
Here, opt.map(Stream::of).orElseGet(Stream::empty) uses the clear contract of Optional: if value present, use it; else, ignore.

Exp:2
		System.out.println("Using orElse:");
        String result1 = Optional.of("Vamshi").orElse(getDefault());
        System.out.println("Result: " + result1);

        System.out.println("\nUsing orElseGet:");
        String result2 = Optional.of("Vamshi").orElseGet(() -> getDefault());
        System.out.println("Result: " + result2);

    public static String getDefault() {
        System.out.println("⚙️ getDefault() called");
        return "Default";
    }

Using orElse:
⚙️ getDefault() called
Result: Vamshi

Using orElseGet:
Result: Vamshi
Even though "Vamshi" was present, getDefault() was still called in orElse() — wasteful!

Example:2

Input:List<String> list1 = Arrays.asList("1", "3", "A", "4", "xyz");

public class Main {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("1", "3", "A", "4", "xyz");

        List<Integer> intList = Optional.ofNullable(list1)
            .map(list -> list.stream()
                .filter(Main::isNumeric) // ✅ Only keep numeric strings
                .map(Integer::parseInt)
                .collect(Collectors.toList()))
            .orElseGet(ArrayList::new);

        System.out.println(intList); // Output: [1, 3, 4]
    }

    // ✅ Utility method to check if a string is numeric
    public static boolean isNumeric(String str) {
        if (str == null || str.isEmpty()) return false;
        try {
            Integer.parseInt(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
Output:[1, 3, 4]
What this does:
Filters out invalid inputs like "A", "xyz", etc.
Only parses valid integers.
Uses Optional.ofNullable() to handle null safely.
Uses orElseGet() for lazy fallback to new ArrayList<>().


Example:3
List<String> list1 = Arrays.asList("1", "3", "4");
List<String> list2 = Arrays.asList("11", "33", "44");
List<List<String>> listOfLists= new ArrayList<List<String>>();
		listOfLists.add(list1);
		listOfLists.add(list2);
		
My Code		
List<Integer> intList2 =Optional.ofNullable(listOfLists).
.flatMap(listOfList-listOfList.stream().map(list->new ArrayList<>().addAll(list)).collect(Collectors.toList())).orElse(new ArrayList<>());

My Code mistakes
1).addAll(...) returns boolean value true or false, not a merged List That's a logic bug.
2).flatMap(...) doesn't work directly with streams here
flatMap is for flattening nested Optionals, not for stream flattening.
3)You’re trying to collect(...) inside flatMap — that won't compile.

public class Main {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("1", "3", "4");
        List<String> list2 = Arrays.asList("11", "33", "44");
        List<List<String>> listOfLists = new ArrayList<>();
        listOfLists.add(list1);
        listOfLists.add(list2);

        List<Integer> intList = Optional.ofNullable(listOfLists)
            .map(listOfList -> listOfList.stream() //Converts list List<List<String>> to Stream<Stream<String>>
                .flatMap(List::stream)  // ✅ flatten nested lists //Converts Stream<Stream<String>> to Stream<String>
                .map(Integer::parseInt) // ✅ convert to Integer   // Converts Stream<String> to Stream<Integer>
                .collect(Collectors.toList()))
            .orElseGet(ArrayList::new);

        System.out.println(intList); // Output: [1, 3, 4, 11, 33, 44]
    }
}


Explanation:
.flatMap(List::stream) flattens the nested lists (List<List<String>>) into a single Stream<String>.
.map(Integer::parseInt) converts each string to an integer.
Optional.ofNullable(...).map(...).orElseGet(...) safely handles null values.



Stream.flatMap:-Flattens multiple streams into a single stream.
List<String> flatList = listOfLists.stream()
    .flatMap(list -> list.stream())  // flattening
    .collect(Collectors.toList());  Output: [1, 3, 4, 11, 33, 44]
Optional.flatMap:- Avoids nested Optionals like Optional<Optional<T>>.






